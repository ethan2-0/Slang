namespace stdlib;

fn die(message: String) {
    let s = new String(['F', 'a', 't', 'a', 'l', ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '], 0, 13);
    let newline = new String([10], 0, 1);
    print(s);
    print(message);
    print(newline);
    exit(1);
}

class String {
    chars: [int];
    startIndex: int;
    length: int;
    ctor(chars: [int], startIndex: int, length: int) {
        if(startIndex + length > #chars) {
            die(new String(['L', 'e', 'n', 'g', 't', 'h', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e'], 0, 16));
        }
        this.chars = chars;
        this.startIndex = startIndex;
        if(length == -1) {
            length = #chars;
        }
        this.length = length;
    }
    fn charAt(index: int): int {
        if(index > this.length) {
            die(new String(['c', 'h', 'a', 'r', 'A', 't', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'u', 't', ' ', 'o', 'f', ' ', 'b', 'o', 'u', 'n', 'd', 's'], 0, 26));
        }
        return this.chars[index + this.startIndex];
    }
    fn _getCleanBuffer(): [int] {
        if(this.startIndex == 0 and this.length == #this.chars) {
            return this.chars;
        }
        let newBuff = [int: this.length];
        for(let i = 0; i < this.length; i++) {
            newBuff[i] = this.chars[this.startIndex + i];
        }
        this.chars = newBuff;
        return newBuff;
    }
    fn concat(other: String): String {
        let newBuff = [int: other.length + this.length];
        let cleanBuff = this._getCleanBuffer();
        let otherCleanBuff = other._getCleanBuffer();
        for(let i = 0; i < #cleanBuff; i++) {
            newBuff[i] = cleanBuff[i];
        }
        for(let i = 0; i < #otherCleanBuff; i++) {
            newBuff[i + #cleanBuff] = otherCleanBuff[i];
        }
        return new String(newBuff, 0, this.length + other.length);
    }
    fn substr(startIndex: int, endIndex: int): String {
        if(startIndex < 0) {
            startIndex = this.length - startIndex;
        }
        if(endIndex < 0) {
            endIndex = this.length - endIndex;
        }
        if(endIndex >= this.length) {
            endIndex = this.length;
        }
        if(startIndex >= this.length or endIndex > this.length) {
            die(new String(['s', 'u', 'b', 's', 't', 'r', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'u', 't', ' ', 'o', 'f', ' ', 'b', 'o', 'u', 'n', 'd', 's'], 0, 26));
        }
        return new String(this.chars, this.startIndex + startIndex, endIndex - startIndex);
    }
    fn substrOpen(startIndex: int): String {
        if(startIndex < 0) {
            startIndex = this.length - startIndex;
        }
        return this.substr(startIndex, this.length);
    }
    fn equals(other: String): bool {
        if(other.length != this.length) {
            return false;
        }
        if(other.chars == this.chars) {
            return this.startIndex == other.startIndex;
        }
        for(let i = 0; i < this.length; i++) {
            if(this.charAt(i) != other.charAt(i)) {
                return false;
            }
        }
        return true;
    }
    fn indexOf(other: String): int {
        for(let i = 0; i <= (this.length - other.length); i++) {
            let isThisTime = true;
            for(let j = 0; j < other.length and isThisTime; j++) {
                if(this.charAt(i + j) != other.charAt(j)) {
                    isThisTime = false;
                }
            }
            if(isThisTime) {
                return i;
            }
        }
        return -1;
    }
    fn indexOfChar(ch: int): int {
        for(let i = 0; i < this.length; i++) {
            if(ch == this.charAt(i)) {
                return i;
            }
        }
        return -1;
    }
    fn contains(other: String): bool {
        return this.indexOf(other) != -1;
    }
    fn containsChar(other: int): bool {
        return this.indexOfChar(other) != -1;
    }
}
fn print(str: String) {
    // This is to work around a compiler bug that I haven't gotten around to fixing yet
    let _ = stdlib.internal.print(str._getCleanBuffer());
}
fn exit(code: int) {
    let _ = stdlib.internal.exit(code);
}
fn getOne(): int {
    return 1;
}